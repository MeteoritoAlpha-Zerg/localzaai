import os
import sys
import json
import logging
import time
import requests
from datetime import datetime, timedelta
from urllib.parse import urljoin, quote

# Setup logging
logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('crowdstrike_verification.log')
    ]
)
L = logging.getLogger(__name__)

def get_oauth_token():
    """
    Get an OAuth token from CrowdStrike API.
    
    Environment variables required:
    - CROWDSTRIKE_HOST: The base URL for CrowdStrike API (e.g., api.crowdstrike.com)
    - CROWDSTRIKE_CLIENT_ID: The client ID for authenticating with CrowdStrike API
    - CROWDSTRIKE_CLIENT_SECRET: The client secret for authenticating with CrowdStrike API
    
    Returns:
    - dict: OAuth token response including access_token, token_type, and expires_in
    - None: If authentication fails
    """
    
    # Get environment variables
    host = os.environ.get('CROWDSTRIKE_HOST')
    client_id = os.environ.get('CROWDSTRIKE_CLIENT_ID')
    client_secret = os.environ.get('CROWDSTRIKE_CLIENT_SECRET')
    
    # Check for missing variables
    missing_vars = []
    if not host:
        missing_vars.append('CROWDSTRIKE_HOST')
    if not client_id:
        missing_vars.append('CROWDSTRIKE_CLIENT_ID')
    if not client_secret:
        missing_vars.append('CROWDSTRIKE_CLIENT_SECRET')
    
    if missing_vars:
        L.error(f"Missing required environment variables: {', '.join(missing_vars)}")
        print(f"Error: Missing required environment variables: {', '.join(missing_vars)}")
        return None
    
    # Ensure host has proper format
    if not host.startswith('http'):
        host = f"https://{host}"
    
    # Setup request parameters
    token_url = f"{host}/oauth2/token"
    headers = {
        'Content-Type': 'application/x-www-form-urlencoded'
    }
    data = {
        'client_id': client_id,
        'client_secret': client_secret,
        'grant_type': 'client_credentials'
    }
    
    try:
        L.info(f"Attempting to authenticate with CrowdStrike API at: {host}")
        response = requests.post(token_url, headers=headers, data=data, timeout=30)
        
        if response.status_code == 201 or response.status_code == 200:
            token_data = response.json()
            L.info("Authentication successful")
            L.debug(f"Token expiration (seconds): {token_data.get('expires_in', 'N/A')}")
            return token_data
        else:
            L.error(f"Authentication failed. Status code: {response.status_code}")
            try:
                error_details = response.json()
                L.error(f"Error details: {json.dumps(error_details, indent=2)}")
            except:
                L.error(f"Response text: {response.text}")
            return None
    
    except requests.exceptions.RequestException as e:
        L.error(f"Exception occurred while authenticating with CrowdStrike API: {e}")
        return None

def verify_crowdstrike_credentials():
    """
    Verify CrowdStrike credentials by obtaining an OAuth token.
    
    Returns:
    - True if credentials are valid
    - False otherwise
    """
    # Get environment variables
    host = os.environ.get('CROWDSTRIKE_HOST')
    client_id = os.environ.get('CROWDSTRIKE_CLIENT_ID')
    client_secret = os.environ.get('CROWDSTRIKE_CLIENT_SECRET')
    
    L.info("Retrieved environment variables:")
    L.info(f"  API Host: {host}")
    L.info(f"  Client ID: {client_id}")
    L.info(f"  Client Secret: {'*****' if client_secret else 'Not set'}")
    
    # Get OAuth token
    token_data = get_oauth_token()
    if not token_data or 'access_token' not in token_data:
        L.error("Failed to obtain OAuth token")
        return False
    
    # If we got a valid token, consider this a success
    L.info("Successfully obtained a valid OAuth token")
    return True

def get_detections(limit=20, days=7):
    """
    Retrieve recent detections from CrowdStrike.
    
    Args:
        limit (int): Maximum number of detections to retrieve
        days (int): Number of days to look back for detections
        
    Returns:
        list: List of detection IDs or None if failed
    """
    token_data = get_oauth_token()
    if not token_data or 'access_token' not in token_data:
        L.error("Failed to obtain OAuth token")
        return None
    
    host = os.environ.get('CROWDSTRIKE_HOST')
    if not host.startswith('http'):
        host = f"https://{host}"
    
    headers = {
        'Authorization': f"Bearer {token_data['access_token']}",
        'Accept': 'application/json',
        'Content-Type': 'application/json'
    }
    
    # Calculate date filter based on last N days
    now = datetime.utcnow()
    start_date = now - timedelta(days=days)
    
    # Format timestamps for CrowdStrike API (use RFC3339 format)
    start_timestamp = start_date.strftime("%Y-%m-%dT%H:%M:%SZ")
    
    # Build the filter based on the creation time - use proper format and URL encode it
    filter_param = f"last_behavior:>='{start_timestamp}'"
    encoded_filter = quote(filter_param)
    
    detections_url = f"{host}/detects/queries/detects/v1?limit={limit}&filter={encoded_filter}"
    
    try:
        L.info(f"Retrieving detections for the last {days} days (limit: {limit})...")
        response = requests.get(detections_url, headers=headers, timeout=30)
        
        if response.status_code == 200:
            data = response.json()
            detection_ids = data.get('resources', [])
            L.info(f"Successfully retrieved {len(detection_ids)} detection IDs")
            return detection_ids
        else:
            L.error(f"Failed to retrieve detections. Status code: {response.status_code}")
            try:
                error_details = response.json()
                L.error(f"Error details: {json.dumps(error_details, indent=2)}")
            except:
                L.error(f"Response text: {response.text}")
            
            # If no detections found, return empty list instead of None
            if response.status_code == 400 and "Invalid argument" in response.text:
                L.warning("No detections found or invalid filter - returning empty list")
                return []
            
            return None
    
    except Exception as e:
        L.error(f"Exception while retrieving detections: {e}")
        return None

def get_detection_details(detection_ids):
    """
    Retrieve details for specific detection IDs.
    
    Args:
        detection_ids (list): List of detection IDs to retrieve details for
        
    Returns:
        dict: JSON response containing detection details or None if failed
    """
    if not detection_ids:
        L.warning("No detection IDs provided - skipping details retrieval")
        return []
    
    token_data = get_oauth_token()
    if not token_data or 'access_token' not in token_data:
        L.error("Failed to obtain OAuth token")
        return None
    
    host = os.environ.get('CROWDSTRIKE_HOST')
    if not host.startswith('http'):
        host = f"https://{host}"
    
    headers = {
        'Authorization': f"Bearer {token_data['access_token']}",
        'Accept': 'application/json',
        'Content-Type': 'application/json'
    }
    
    # CrowdStrike API expects detection IDs as a JSON string array
    ids_json = json.dumps({"ids": detection_ids})
    details_url = f"{host}/detects/entities/summaries/GET/v1"
    
    try:
        L.info(f"Retrieving details for {len(detection_ids)} detections...")
        response = requests.post(details_url, headers=headers, data=ids_json, timeout=30)
        
        if response.status_code == 200:
            data = response.json()
            detections = data.get('resources', [])
            L.info(f"Successfully retrieved details for {len(detections)} detections")
            return detections
        else:
            L.error(f"Failed to retrieve detection details. Status code: {response.status_code}")
            try:
                error_details = response.json()
                L.error(f"Error details: {json.dumps(error_details, indent=2)}")
            except:
                L.error(f"Response text: {response.text}")
            return None
    
    except Exception as e:
        L.error(f"Exception while retrieving detection details: {e}")
        return None

def get_iocs(limit=20, days=30):
    """
    Retrieve recent Indicators of Compromise (IOCs) from CrowdStrike.
    
    Args:
        limit (int): Maximum number of IOCs to retrieve
        days (int): Number of days to look back for IOCs
        
    Returns:
        list: List of IOC IDs or None if failed
    """
    token_data = get_oauth_token()
    if not token_data or 'access_token' not in token_data:
        L.error("Failed to obtain OAuth token")
        return None
    
    host = os.environ.get('CROWDSTRIKE_HOST')
    if not host.startswith('http'):
        host = f"https://{host}"
    
    headers = {
        'Authorization': f"Bearer {token_data['access_token']}",
        'Accept': 'application/json',
        'Content-Type': 'application/json'
    }
    
    # Calculate date filter based on last N days
    now = datetime.utcnow()
    start_date = now - timedelta(days=days)
    
    # Format timestamps for CrowdStrike API (RFC3339)
    start_timestamp = start_date.strftime("%Y-%m-%dT%H:%M:%SZ")
    
    # Build the filter based on the creation time
    filter_param = f"created_on:>'{start_timestamp}'"
    encoded_filter = quote(filter_param)
    iocs_url = f"{host}/iocs/queries/indicators/v1?limit={limit}&filter={encoded_filter}"
    
    try:
        L.info(f"Retrieving IOCs for the last {days} days (limit: {limit})...")
        response = requests.get(iocs_url, headers=headers, timeout=30)
        
        if response.status_code == 200:
            data = response.json()
            ioc_ids = data.get('resources', [])
            L.info(f"Successfully retrieved {len(ioc_ids)} IOC IDs")
            return ioc_ids
        elif response.status_code == 404:
            L.warning("No IOCs found or the endpoint is not available")
            return []
        else:
            L.error(f"Failed to retrieve IOCs. Status code: {response.status_code}")
            try:
                error_details = response.json()
                L.error(f"Error details: {json.dumps(error_details, indent=2)}")
            except:
                L.error(f"Response text: {response.text}")
            return None
    
    except Exception as e:
        L.error(f"Exception while retrieving IOCs: {e}")
        return None

def explore_query_targets():
    """
    Explore available query targets in the CrowdStrike API.
    This simulates what get_query_target_options would return in the actual connector.
    
    Returns:
        dict: Dictionary of available query targets or None if failed
    """
    L.info("Exploring available CrowdStrike API query targets")
    
    # These are the standard query targets for CrowdStrike based on its API documentation
    # In a real implementation, we would verify these with API calls
    query_targets = {
        "detections": {
            "description": "Information about security detections/incidents",
            "endpoints": [
                {"name": "list_detections", "path": "/detects/queries/detects/v1", "description": "List detection IDs"},
                {"name": "get_detection_details", "path": "/detects/entities/summaries/GET/v1", "description": "Get details for specific detections"}
            ]
        },
        "iocs": {
            "description": "Information about Indicators of Compromise",
            "endpoints": [
                {"name": "list_iocs", "path": "/iocs/queries/indicators/v1", "description": "List IOC IDs"},
                {"name": "get_ioc_details", "path": "/iocs/entities/indicators/v1", "description": "Get details for specific IOCs"}
            ]
        },
        "incidents": {
            "description": "Information about security incidents",
            "endpoints": [
                {"name": "list_incidents", "path": "/incidents/queries/incidents/v1", "description": "List incident IDs"},
                {"name": "get_incident_details", "path": "/incidents/entities/incidents/v1", "description": "Get details for specific incidents"}
            ]
        },
        "device_actions": {
            "description": "Actions that can be performed on devices",
            "endpoints": [
                {"name": "contain_host", "path": "/devices/entities/devices-actions/v2", "description": "Contain/isolate a host"},
                {"name": "lift_containment", "path": "/devices/entities/devices-actions/v2", "description": "Remove containment from a host"}
            ]
        }
    }
    
    # Verify authentication to CrowdStrike API
    if verify_crowdstrike_credentials():
        L.info("Verified connection to CrowdStrike API")
        L.info(f"Enumerated {len(query_targets)} query targets")
        return query_targets
    else:
        L.error("Failed to connect to CrowdStrike API, cannot verify query targets")
        return None

def test_detections_retrieval():
    """
    Test retrieving detection data from CrowdStrike.
    
    Returns:
        bool: True if tests passed, False otherwise
    """
    L.info("\n=== Testing Detection Data Retrieval ===")
    detection_ids = get_detections(limit=5, days=30)
    
    if detection_ids is None:
        print("❌ Failed to query detections")
        return False
    
    if not detection_ids:
        L.warning("No detections found in the last 30 days")
        print("⚠️ No detections found in the last 30 days")
        return True  # Not a failure, just no data
    
    L.info(f"✅ Successfully retrieved {len(detection_ids)} detection IDs")
    
    # Display detection IDs
    L.info(f"Detection IDs: {', '.join(detection_ids[:5])}")
    
    # Test retrieving details for detections
    if detection_ids:
        L.info("\n=== Testing Detection Details Retrieval ===")
        sample_ids = detection_ids[:2]  # Get details for up to 2 detections
        L.info(f"Getting details for {len(sample_ids)} detections")
        
        detection_details = get_detection_details(sample_ids)
        
        if detection_details:
            L.info(f"✅ Successfully retrieved details for {len(detection_details)} detections")
            
            # Display key information about the first detection
            if detection_details:
                L.info("\nSample Detection Details:")
                first_detection = detection_details[0]
                L.info(f"  ID: {first_detection.get('detection_id', 'N/A')}")
                L.info(f"  Type: {first_detection.get('name', 'N/A')}")
                L.info(f"  Severity: {first_detection.get('max_severity_displayname', 'N/A')}")
                L.info(f"  Status: {first_detection.get('status', 'N/A')}")
                L.info(f"  Hostname: {first_detection.get('device', {}).get('hostname', 'N/A')}")
                
            return True
        else:
            L.error("❌ Failed to retrieve detection details")
            return False
    else:
        L.warning("Cannot test detection details retrieval - no detection IDs found")
        return True  # Not a failure, just no data

def main():
    L.info("Starting CrowdStrike credential verification")
    
    if len(sys.argv) > 1 and sys.argv[1] == '--set-env':
        L.info("Using manual credential input mode")
        
        if not os.environ.get('CROWDSTRIKE_HOST'):
            os.environ['CROWDSTRIKE_HOST'] = input("Enter CrowdStrike API host (e.g., api.crowdstrike.com): ")
        if not os.environ.get('CROWDSTRIKE_CLIENT_ID'):
            os.environ['CROWDSTRIKE_CLIENT_ID'] = input("Enter CrowdStrike client ID: ")
        if not os.environ.get('CROWDSTRIKE_CLIENT_SECRET'):
            os.environ['CROWDSTRIKE_CLIENT_SECRET'] = input("Enter CrowdStrike client secret: ")
    else:
        L.info("Using environment variables for credentials")
    
    # Basic credential verification
    L.info("\n=== Basic Credential Verification ===")
    success = verify_crowdstrike_credentials()
    
    if not success:
        L.error("Basic credential verification failed")
        return 1
    
    # Explore query targets
    L.info("\n=== Exploring API Query Targets ===")
    query_targets = explore_query_targets()
    
    # Extended testing - Detection Data
    L.info("\n=== Extended Verification: Detection Data ===")
    detection_test_success = test_detections_retrieval()
    
    if success and detection_test_success:
        L.info("All credential verification tests completed successfully")
        return 0
    elif success:
        L.warning("Basic verification passed but extended tests failed")
        return 0  # Still return success since basic auth worked
    else:
        L.error("Credential verification failed")
        return 1

if __name__ == "__main__":
    sys.exit(main())