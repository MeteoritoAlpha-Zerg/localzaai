import os
import sys
import json
import logging
import random
import time
import requests
from datetime import datetime, timedelta
from urllib.parse import urljoin, quote

# Setup logging
logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[
        logging.StreamHandler(),
        logging.FileHandler('crowdstrike_test_data.log')
    ]
)
L = logging.getLogger(__name__)

def verify_crowdstrike_credentials():
    """
    Verify CrowdStrike credentials by obtaining an OAuth token.
    
    Returns:
    - True if credentials are valid
    - False otherwise
    """
    # Get environment variables
    host = os.environ.get('CROWDSTRIKE_HOST')
    client_id = os.environ.get('CROWDSTRIKE_CLIENT_ID')
    client_secret = os.environ.get('CROWDSTRIKE_CLIENT_SECRET')
    
    L.info("Retrieved environment variables:")
    L.info(f"  API Host: {host}")
    L.info(f"  Client ID: {client_id}")
    L.info(f"  Client Secret: {'*****' if client_secret else 'Not set'}")
    
    # Get OAuth token
    token_data = get_oauth_token()
    if not token_data or 'access_token' not in token_data:
        L.error("Failed to obtain OAuth token")
        return False
    
    # If we got a valid token, consider this a success
    L.info("Successfully obtained a valid OAuth token")
    return True

def get_oauth_token():
    """
    Get an OAuth token from CrowdStrike API.
    
    Environment variables required:
    - CROWDSTRIKE_HOST: The base URL for CrowdStrike API (e.g., api.crowdstrike.com)
    - CROWDSTRIKE_CLIENT_ID: The client ID for authenticating with CrowdStrike API
    - CROWDSTRIKE_CLIENT_SECRET: The client secret for authenticating with CrowdStrike API
    
    Returns:
    - dict: OAuth token response including access_token, token_type, and expires_in
    - None: If authentication fails
    """
    
    # Get environment variables
    host = os.environ.get('CROWDSTRIKE_HOST')
    client_id = os.environ.get('CROWDSTRIKE_CLIENT_ID')
    client_secret = os.environ.get('CROWDSTRIKE_CLIENT_SECRET')
    
    # Check for missing variables
    missing_vars = []
    if not host:
        missing_vars.append('CROWDSTRIKE_HOST')
    if not client_id:
        missing_vars.append('CROWDSTRIKE_CLIENT_ID')
    if not client_secret:
        missing_vars.append('CROWDSTRIKE_CLIENT_SECRET')
    
    if missing_vars:
        L.error(f"Missing required environment variables: {', '.join(missing_vars)}")
        print(f"Error: Missing required environment variables: {', '.join(missing_vars)}")
        return None
    
    # Ensure host has proper format
    if not host.startswith('http'):
        host = f"https://{host}"
    
    # Setup request parameters
    token_url = f"{host}/oauth2/token"
    headers = {
        'Content-Type': 'application/x-www-form-urlencoded'
    }
    data = {
        'client_id': client_id,
        'client_secret': client_secret,
        'grant_type': 'client_credentials'
    }
    
    try:
        L.info(f"Attempting to authenticate with CrowdStrike API at: {host}")
        response = requests.post(token_url, headers=headers, data=data, timeout=30)
        
        if response.status_code == 201 or response.status_code == 200:
            token_data = response.json()
            L.info("Authentication successful")
            L.debug(f"Token expiration (seconds): {token_data.get('expires_in', 'N/A')}")
            return token_data
        else:
            L.error(f"Authentication failed. Status code: {response.status_code}")
            try:
                error_details = response.json()
                L.error(f"Error details: {json.dumps(error_details, indent=2)}")
            except:
                L.error(f"Response text: {response.text}")
            return None
    
    except requests.exceptions.RequestException as e:
        L.error(f"Exception occurred while authenticating with CrowdStrike API: {e}")
        return None

# Other existing functions (create_sample_hosts, create_sample_detections, etc.) remain the same

def upload_sample_iocs_to_crowdstrike(iocs):
    """
    Upload sample IOCs to CrowdStrike using the API.
    
    Args:
        iocs (list): List of IOC dictionaries
    
    Returns:
        bool: True if upload was successful, False otherwise
    """
    L.info(f"Uploading {len(iocs)} IOCs to CrowdStrike API")
    
    # Get OAuth token
    token_data = get_oauth_token()
    if not token_data or 'access_token' not in token_data:
        L.error("Failed to obtain OAuth token for IOC upload")
        return False
    
    access_token = token_data['access_token']
    host = os.environ.get('CROWDSTRIKE_HOST')
    if not host.startswith('http'):
        host = f"https://{host}"
    
    # CrowdStrike API endpoint for IOC upload
    ioc_url = f"{host}/indicators/entities/iocs/v1"
    
    # Format IOCs for CrowdStrike API
    formatted_iocs = []
    for ioc in iocs:
        # Map our IOC type to CrowdStrike IOC type
        cs_type = "domain"
        if ioc['type'] == 'ip_address':
            cs_type = "ipv4"
        elif ioc['type'] == 'hash_md5':
            cs_type = "md5"
        elif ioc['type'] == 'hash_sha256':
            cs_type = "sha256"
        elif ioc['type'] == 'file_path':
            cs_type = "file_path"
        
        # Map our severity to CrowdStrike severity
        cs_severity = "medium"
        if ioc['severity'] == 'Low':
            cs_severity = "low"
        elif ioc['severity'] == 'High':
            cs_severity = "high"
        elif ioc['severity'] == 'Critical':
            cs_severity = "critical"
        
        formatted_ioc = {
            "type": cs_type,
            "value": ioc['value'],
            "policy": "detect",
            "share_level": "red",  # Internal only
            "source": "Custom Script",
            "description": ioc['description'],
            "expiration": ioc['expires_on'],
            "severity": cs_severity,
            "mobile_action": "block",
        }
        formatted_iocs.append(formatted_ioc)
    
    # Setup headers with OAuth token
    headers = {
        'Content-Type': 'application/json',
        'Authorization': f'Bearer {access_token}'
    }
    
    # Upload IOCs in batches of 100 (CrowdStrike API limit)
    batch_size = 100
    success_count = 0
    
    for i in range(0, len(formatted_iocs), batch_size):
        batch = formatted_iocs[i:i+batch_size]
        
        try:
            response = requests.post(
                ioc_url, 
                headers=headers, 
                json=batch,
                timeout=60
            )
            
            if response.status_code == 200 or response.status_code == 201:
                batch_result = response.json()
                L.info(f"Successfully uploaded batch of {len(batch)} IOCs")
                L.debug(f"Upload result: {json.dumps(batch_result, indent=2)}")
                success_count += len(batch)
            else:
                L.error(f"Failed to upload IOC batch. Status code: {response.status_code}")
                try:
                    error_details = response.json()
                    L.error(f"Error details: {json.dumps(error_details, indent=2)}")
                except:
                    L.error(f"Response text: {response.text}")
        
        except requests.exceptions.RequestException as e:
            L.error(f"Exception occurred during IOC upload: {e}")
    
    L.info(f"Successfully uploaded {success_count}/{len(formatted_iocs)} IOCs")
    return success_count > 0

def create_detection_with_real_device_id(device_id, detection_data):
    """
    Create a custom detection for a real device ID.
    
    Args:
        device_id (str): Real CrowdStrike device ID
        detection_data (dict): Detection data template
        
    Returns:
        dict: Modified detection data with real device ID
    """
    # Clone the detection data
    detection = detection_data.copy()
    
    # Replace the host_id with the real device ID
    detection['host_id'] = device_id
    
    return detection

def get_real_device_ids():
    """
    Get real device IDs from CrowdStrike API.
    
    Returns:
        list: List of device IDs, or empty list if failed
    """
    L.info("Retrieving real device IDs from CrowdStrike API")
    
    # Get OAuth token
    token_data = get_oauth_token()
    if not token_data or 'access_token' not in token_data:
        L.error("Failed to obtain OAuth token for device ID retrieval")
        return []
    
    access_token = token_data['access_token']
    host = os.environ.get('CROWDSTRIKE_HOST')
    if not host.startswith('http'):
        host = f"https://{host}"
    
    # CrowdStrike API endpoint for hosts/devices query
    devices_url = f"{host}/devices/queries/devices/v1"
    
    # Setup headers with OAuth token
    headers = {
        'Content-Type': 'application/json',
        'Authorization': f'Bearer {access_token}'
    }
    
    # Query parameters - limit to a small number for testing
    params = {
        'limit': 10,
        'offset': 0,
        'sort': 'hostname.asc'
    }
    
    try:
        response = requests.get(
            devices_url, 
            headers=headers, 
            params=params,
            timeout=30
        )
        
        if response.status_code == 200:
            result = response.json()
            device_ids = result.get('resources', [])
            L.info(f"Retrieved {len(device_ids)} device IDs from CrowdStrike API")
            return device_ids
        else:
            L.error(f"Failed to retrieve device IDs. Status code: {response.status_code}")
            try:
                error_details = response.json()
                L.error(f"Error details: {json.dumps(error_details, indent=2)}")
            except:
                L.error(f"Response text: {response.text}")
            return []
    
    except requests.exceptions.RequestException as e:
        L.error(f"Exception occurred during device ID retrieval: {e}")
        return []

def create_custom_ioa_rule(device_id, count=3):
    """
    Create a custom IOA rule to generate alerts for a specific device.
    
    Args:
        device_id (str): Real CrowdStrike device ID
        count (int): Number of rules to create
        
    Returns:
        bool: True if successful, False otherwise
    """
    # Get OAuth token
    token_data = get_oauth_token()
    if not token_data or 'access_token' not in token_data:
        L.error("Failed to obtain OAuth token for IOA rule creation")
        return False
    
    access_token = token_data['access_token']
    host = os.environ.get('CROWDSTRIKE_HOST')
    if not host.startswith('http'):
        host = f"https://{host}"
    
    # CrowdStrike API endpoint for custom IOA rules
    rule_url = f"{host}/ioarules/entities/rules/v1"
    
    headers = {
        'Content-Type': 'application/json',
        'Authorization': f'Bearer {access_token}'
    }
    
    # Create rules targeting common processes to trigger alerts
    process_names = ["svchost.exe", "powershell.exe", "cmd.exe"]
    
    success = False
    for i in range(min(count, len(process_names))):
        rule = {
            "name": f"Test Rule for {device_id[:8]} - {i}",
            "description": f"Test rule to generate alerts for device {device_id}",
            "pattern_severity": "informational",
            "enabled": True,
            "platform": "windows",
            "instance_id": str(int(time.time())),
            "rulegroup_id": "default",
            "ruletype_id": "process",
            "field_values": [
                {
                    "name": "FileName", 
                    "label": "file_name",
                    "values": [process_names[i]],
                    "type": "equals"
                }
            ],
            "disposition_id": 0,
            "comment": "Generated by test script"
        }
        
        try:
            response = requests.post(
                rule_url, 
                headers=headers, 
                json=rule,
                timeout=60
            )
            
            if response.status_code in [200, 201, 202]:
                result = response.json()
                L.info(f"Successfully created IOA rule targeting {process_names[i]}")
                success = True
            else:
                L.error(f"Failed to create IOA rule. Status code: {response.status_code}")
                try:
                    error_details = response.json()
                    L.error(f"Error details: {json.dumps(error_details, indent=2)}")
                except:
                    L.error(f"Response text: {response.text}")
        
        except requests.exceptions.RequestException as e:
            L.error(f"Exception during IOA rule creation: {e}")
    
    if success:
        print(f"✅ Created IOA rules that should generate alerts for device {device_id}")
        print("Note: You may need to trigger some system activity for these rules to generate alerts")
        print("Try running some PowerShell or CMD commands on the device to trigger the rules")
    else:
        print(f"❌ Failed to create rules for generating alerts on device {device_id}")
        print("You may need to create test alerts manually in the CrowdStrike console")
    
    return success

def simulate_security_events_for_device(device_id, count=3):
    """
    Simulate security events for a real device to create alerts using Detection Rules API.
    
    Args:
        device_id (str): Real CrowdStrike device ID
        count (int): Number of events to simulate
        
    Returns:
        bool: True if simulation was successful, False otherwise
    """
    L.info(f"Simulating {count} security events for device {device_id}")
    
    # Get OAuth token
    token_data = get_oauth_token()
    if not token_data or 'access_token' not in token_data:
        L.error("Failed to obtain OAuth token for event simulation")
        return False
    
    access_token = token_data['access_token']
    host = os.environ.get('CROWDSTRIKE_HOST')
    if not host.startswith('http'):
        host = f"https://{host}"
    
    # CrowdStrike API endpoint for custom detections
    detections_url = f"{host}/detects/entities/detects/v2"
    
    # Create custom detections for this device
    custom_detections = []
    
    # Sample detection types
    detection_types = [
        'Suspicious Process Activity',
        'Suspicious Script Execution',
        'Defense Evasion via Process Injection'
    ]
    
    # Sample tactics
    tactics = [
        'Defense Evasion',
        'Execution',
        'Persistence'
    ]
    
    # Sample techniques
    techniques = [
        'T1059 - Command and Scripting Interpreter',
        'T1053 - Scheduled Task/Job',
        'T1055 - Process Injection'
    ]
    
    current_time = datetime.utcnow().isoformat()
    
    for i in range(count):
        detection = {
            "id": f"test-detection-{device_id[:8]}-{i}-{int(time.time())}",
            "device_id": device_id,
            "detection_name": detection_types[i % len(detection_types)],
            "severity": random.choice(["Low", "Medium", "High"]),
            "status": "new",
            "tactic": tactics[i % len(tactics)],
            "technique": techniques[i % len(techniques)],
            "timestamp": current_time,
            "description": f"Test detection generated by script for device {device_id}",
            "source": "custom_script"
        }
        custom_detections.append(detection)
    
    # Setup headers with OAuth token
    headers = {
        'Content-Type': 'application/json',
        'Authorization': f'Bearer {access_token}',
        'Accept': 'application/json'
    }
    
    try:
        # Try to create custom detections
        response = requests.post(
            detections_url, 
            headers=headers, 
            json=custom_detections,
            timeout=60
        )
        
        if response.status_code in [200, 201, 202]:
            result = response.json()
            L.info(f"Successfully created {count} custom detections for device {device_id}")
            L.debug(f"Response: {json.dumps(result, indent=2)}")
            print(f"✅ Created {count} simulated security events for device {device_id}")
            print(f"Note: It may take some time for these events to appear as alerts in the CrowdStrike console")
            return True
        else:
            L.error(f"Failed to create custom detections. Status code: {response.status_code}")
            try:
                error_details = response.json()
                L.error(f"Error details: {json.dumps(error_details, indent=2)}")
            except:
                L.error(f"Response text: {response.text}")
            
            # If this approach fails, try a different API method
            L.info("Attempting alternative method: creating custom IOAs")
            return create_custom_ioa_rule(device_id, count)
    
    except requests.exceptions.RequestException as e:
        L.error(f"Exception occurred during detection creation: {e}")
        return False

def main():
    L.info("Starting CrowdStrike test data generation and upload")
    
    if len(sys.argv) > 1 and sys.argv[1] == '--set-env':
        L.info("Using manual credential input mode")
        
        if not os.environ.get('CROWDSTRIKE_HOST'):
            os.environ['CROWDSTRIKE_HOST'] = input("Enter CrowdStrike API host (e.g., api.crowdstrike.com): ")
        if not os.environ.get('CROWDSTRIKE_CLIENT_ID'):
            os.environ['CROWDSTRIKE_CLIENT_ID'] = input("Enter CrowdStrike client ID: ")
        if not os.environ.get('CROWDSTRIKE_CLIENT_SECRET'):
            os.environ['CROWDSTRIKE_CLIENT_SECRET'] = input("Enter CrowdStrike client secret: ")
    else:
        L.info("Using environment variables for credentials")
    
    # Basic credential verification
    L.info("\n=== Basic Credential Verification ===")
    credential_success = verify_crowdstrike_credentials()
    
    if not credential_success:
        L.error("Basic credential verification failed. Cannot upload test data to CrowdStrike.")
        print("❌ Credential verification failed. Generating offline test data only.")
        # Continue to generate offline data even if credentials fail
        
        # Generate test data
        L.info("\n=== Generating Test Data ===")
        test_data = generate_test_data()
        
        # Save test data to file
        save_test_data_to_json(test_data)
        
        # Print summary
        resource_counts = test_data['metadata']['resource_counts']
        print("\n=== Test Data Generation Summary ===")
        print(f"✅ Generated {resource_counts['hosts']} sample hosts")
        print(f"✅ Generated {resource_counts['detections']} sample detections")
        print(f"✅ Generated {resource_counts['iocs']} sample IOCs")
        print(f"✅ Generated {resource_counts['incidents']} sample incidents")
        print(f"✅ Generated {resource_counts['prevention_blocks']} sample prevention blocks")
        print(f"✅ Generated {resource_counts['vulnerabilities']} sample vulnerabilities")
        print(f"✅ Generated {resource_counts['custom_ioc_lists']} custom IOC list(s)")
        
        L.info("CrowdStrike test data generation completed successfully!")
        print("\nCrowdStrike test data generation completed successfully!")
        print("\nNote: Due to credential verification failure, data was not uploaded to CrowdStrike.")
        
        return 1
    
    L.info("✅ CrowdStrike credentials verified successfully")
    print("✅ CrowdStrike credentials verified successfully")
    
    # Get real device IDs from CrowdStrike
    device_ids = get_real_device_ids()
    
    if not device_ids:
        L.error("Failed to retrieve real device IDs. Cannot continue with alert generation.")
        print("❌ Failed to retrieve device IDs from CrowdStrike API.")
        return 1
    
    print(f"\nFound {len(device_ids)} devices in your CrowdStrike instance.")
    
    # Ask user if they want to generate alerts for all devices or a specific one
    if len(device_ids) > 1:
        print("\nAvailable devices:")
        for i, device_id in enumerate(device_ids):
            print(f"{i+1}. {device_id}")
        
        selection = input("\nWhich device would you like to generate alerts for? (Enter number, or 'all' for all devices): ")
        
        if selection.lower() == 'all':
            target_devices = device_ids
        else:
            try:
                index = int(selection) - 1
                if 0 <= index < len(device_ids):
                    target_devices = [device_ids[index]]
                else:
                    print("Invalid selection. Using the first device.")
                    target_devices = [device_ids[0]]
            except ValueError:
                print("Invalid input. Using the first device.")
                target_devices = [device_ids[0]]
    else:
        target_devices = device_ids
    
    # Generate and upload test data for each target device
    for device_id in target_devices:
        print(f"\n=== Generating alerts for device {device_id} ===")
        
        # Ask for number of alerts to generate
        try:
            alert_count = int(input(f"How many alerts would you like to generate for device {device_id}? (1-10, default: 3): "))
            if alert_count < 1 or alert_count > 10:
                print("Number must be between 1 and 10. Using default of 3.")
                alert_count = 3
        except ValueError:
            print("Invalid input. Using default of 3 alerts.")
            alert_count = 3
        
        # Simulate security events to generate alerts
        simulate_security_events_for_device(device_id, count=alert_count)
    
    print("\n=== Alert Generation Summary ===")
    print(f"✅ Attempted to generate alerts for {len(target_devices)} device(s)")
    print("Note: It may take several minutes for alerts to appear in your CrowdStrike console.")
    print("You can now run your unit tests against these alerts.")
    
    return 0

if __name__ == "__main__":
    sys.exit(main())