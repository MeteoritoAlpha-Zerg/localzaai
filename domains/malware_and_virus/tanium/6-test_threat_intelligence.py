# 6-test_threat_intelligence.py

async def test_threat_intelligence(zerg_state=None):
    """Test Tanium threat intelligence and security findings retrieval"""
    print("Attempting to retrieve threat intelligence using Tanium connector")

    assert zerg_state, "this test requires valid zerg_state"

    tanium_url = zerg_state.get("tanium_url").get("value")
    tanium_username = zerg_state.get("tanium_username", {}).get("value")
    tanium_password = zerg_state.get("tanium_password", {}).get("value")
    tanium_domain = zerg_state.get("tanium_domain", {}).get("value")
    tanium_api_token = zerg_state.get("tanium_api_token", {}).get("value")

    from connectors.tanium.config import TaniumConnectorConfig
    from connectors.tanium.connector import TaniumConnector
    from connectors.tanium.tools import TaniumConnectorTools
    from connectors.tanium.target import TaniumTarget

    from connectors.config import ConnectorConfig
    from connectors.connector import Connector, ConnectorTargetInterface
    from connectors.query_target_options import ConnectorQueryTargetOptions

    # set up the config - prefer API token over username/password
    if tanium_api_token:
        config = TaniumConnectorConfig(
            url=tanium_url,
            api_token=tanium_api_token,
        )
    elif tanium_username and tanium_password:
        config = TaniumConnectorConfig(
            url=tanium_url,
            username=tanium_username,
            password=tanium_password,
            domain=tanium_domain,  # domain is optional
        )
    else:
        raise Exception("Either tanium_api_token or both tanium_username and tanium_password must be provided")

    assert isinstance(config, ConnectorConfig), "TaniumConnectorConfig should be of type ConnectorConfig"

    # set up the connector
    connector = TaniumConnector
    await connector.initialize(
        config=config,
        user_id="test_user_id",
        encryption_key="test_enc_key"
    )
    assert isinstance(connector, Connector), "TaniumConnector should be of type Connector"

    # get query target options
    tanium_query_target_options = await connector.get_query_target_options()
    assert isinstance(tanium_query_target_options, ConnectorQueryTargetOptions), "query target options should be of type ConnectorQueryTargetOptions"

    # select computer groups to target
    computer_group_selector = None
    for selector in tanium_query_target_options.selectors:
        if selector.type == 'computer_group_ids':  
            computer_group_selector = selector
            break

    assert computer_group_selector, "failed to retrieve computer group selector from query target options"

    assert isinstance(computer_group_selector.values, list), "computer_group_selector values must be a list"
    computer_group_id = computer_group_selector.values[0] if computer_group_selector.values else None
    print(f"Selecting computer group ID: {computer_group_id}")

    assert computer_group_id, f"failed to retrieve computer group ID from computer group selector"

    # set up the target with computer group IDs
    target = TaniumTarget(computer_group_ids=[computer_group_id])
    assert isinstance(target, ConnectorTargetInterface), "TaniumTarget should be of type ConnectorTargetInterface"

    # get tools
    tools = await connector.get_tools(
        target=target
    )
    assert isinstance(tools, list), "Tools response is not a list"

    # Test 1: Get threat response alerts
    get_tanium_threat_response_tool = next(tool for tool in tools if tool.name == "get_tanium_threat_response")
    tanium_threat_response_result = await get_tanium_threat_response_tool.execute(
        computer_group_id=computer_group_id,
        limit=20  # limit to 20 alerts for testing
    )
    tanium_threat_alerts = tanium_threat_response_result.result

    print("Type of returned tanium_threat_alerts:", type(tanium_threat_alerts))
    print(f"len threat alerts: {len(tanium_threat_alerts)} alerts: {str(tanium_threat_alerts)[:200]}")

    # Verify that tanium_threat_alerts is a list
    assert isinstance(tanium_threat_alerts, list), "tanium_threat_alerts should be a list"
    
    # Threat alerts might be empty, which is acceptable
    if len(tanium_threat_alerts) > 0:
        # Limit the number of alerts to check if there are many
        alerts_to_check = tanium_threat_alerts[:3] if len(tanium_threat_alerts) > 3 else tanium_threat_alerts
        
        # Verify structure of each threat alert object
        for alert in alerts_to_check:
            # Verify essential Tanium threat response fields
            assert "guid" in alert, "Each threat alert should have a 'guid' field"
            assert "computer_name" in alert, "Each threat alert should have a 'computer_name' field"
            assert "type" in alert, "Each threat alert should have a 'type' field"
            
            # Verify common threat response fields
            assert "created_at" in alert, "Each threat alert should have a 'created_at' field"
            assert "severity" in alert, "Each threat alert should have a 'severity' field"
            
            # Check for common threat types
            valid_threat_types = ["malware", "suspicious_activity", "policy_violation", "network_anomaly", "file_execution", "registry_modification"]
            
            # Check for additional optional fields
            optional_fields = ["description", "file_path", "process_name", "command_line", "hash", "reputation"]
            present_optional = [field for field in optional_fields if field in alert]
            
            print(f"Threat alert {alert['guid']} ({alert['type']}) contains these optional fields: {', '.join(present_optional)}")
            
            # Log the structure of the first alert for debugging
            if alert == alerts_to_check[0]:
                print(f"Example threat alert structure: {alert}")

        print(f"Successfully retrieved and validated {len(tanium_threat_alerts)} Tanium threat alerts")
    else:
        print("No threat alerts found - this is acceptable for testing")

    # Test 2: Get IOC detections
    get_tanium_ioc_detections_tool = next(tool for tool in tools if tool.name == "get_tanium_ioc_detections")
    tanium_ioc_detections_result = await get_tanium_ioc_detections_tool.execute(
        computer_group_id=computer_group_id,
        limit=15  # limit to 15 IOC detections for testing
    )
    tanium_ioc_detections = tanium_ioc_detections_result.result

    print("Type of returned tanium_ioc_detections:", type(tanium_ioc_detections))
    print(f"len IOC detections: {len(tanium_ioc_detections)} detections: {str(tanium_ioc_detections)[:200]}")

    # Verify that tanium_ioc_detections is a list
    assert isinstance(tanium_ioc_detections, list), "tanium_ioc_detections should be a list"
    
    # IOC detections might be empty, which is acceptable
    if len(tanium_ioc_detections) > 0:
        # Limit the number of detections to check
        detections_to_check = tanium_ioc_detections[:3] if len(tanium_ioc_detections) > 3 else tanium_ioc_detections
        
        # Verify structure of each IOC detection object
        for detection in detections_to_check:
            # Verify essential Tanium IOC detection fields
            assert "id" in detection, "Each IOC detection should have an 'id' field"
            assert "computer_name" in detection, "Each IOC detection should have a 'computer_name' field"
            assert "ioc_name" in detection, "Each IOC detection should have an 'ioc_name' field"
            
            # Verify common IOC detection fields
            assert "detected_at" in detection, "Each IOC detection should have a 'detected_at' field"
            assert "ioc_type" in detection, "Each IOC detection should have an 'ioc_type' field"
            
            # Check for common IOC types
            valid_ioc_types = ["file_hash", "ip_address", "domain", "url", "file_path", "registry_key", "mutex"]
            assert detection["ioc_type"] in valid_ioc_types, f"IOC type {detection['ioc_type']} is not a recognized type"
            
            # Check for additional optional fields
            optional_fields = ["description", "match_value", "confidence", "source", "category"]
            present_optional = [field for field in optional_fields if field in detection]
            
            print(f"IOC detection {detection['id']} ({detection['ioc_type']}) contains these optional fields: {', '.join(present_optional)}")
            
            # Log the structure of the first detection for debugging
            if detection == detections_to_check[0]:
                print(f"Example IOC detection structure: {detection}")

        print(f"Successfully retrieved and validated {len(tanium_ioc_detections)} Tanium IOC detections")
    else:
        print("No IOC detections found - this is acceptable for testing")

    # Test 3: Get security findings from Detect module
    get_tanium_detect_findings_tool = next(tool for tool in tools if tool.name == "get_tanium_detect_findings")
    tanium_detect_findings_result = await get_tanium_detect_findings_tool.execute(
        computer_group_id=computer_group_id,
        limit=10  # limit to 10 findings for testing
    )
    tanium_detect_findings = tanium_detect_findings_result.result

    print("Type of returned tanium_detect_findings:", type(tanium_detect_findings))
    print(f"len detect findings: {len(tanium_detect_findings)} findings: {str(tanium_detect_findings)[:200]}")

    # Verify that tanium_detect_findings is a list
    assert isinstance(tanium_detect_findings, list), "tanium_detect_findings should be a list"
    
    # Detect findings might be empty, which is acceptable
    if len(tanium_detect_findings) > 0:
        # Check structure of detect findings
        findings_to_check = tanium_detect_findings[:3] if len(tanium_detect_findings) > 3 else tanium_detect_findings
        
        for finding in findings_to_check:
            assert "id" in finding, "Each detect finding should have an 'id' field"
            assert "rule_name" in finding, "Each detect finding should have a 'rule_name' field"
            assert "computer_name" in finding, "Each detect finding should have a 'computer_name' field"
            
            print(f"Detect finding {finding['id']} for rule {finding['rule_name']}")

        print(f"Successfully retrieved and validated {len(tanium_detect_findings)} Tanium Detect findings")
    else:
        print("No Detect findings found - this is acceptable for testing")

    print("Successfully completed threat intelligence and security findings tests")

    return True