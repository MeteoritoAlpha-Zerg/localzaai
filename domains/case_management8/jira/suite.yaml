name: manifest_suite
description: Manifest suite

domains:
  case_management8 !include domains/case_management8/case_management8.yaml

tests:
-   description: 'This checks to see that the connector is able to return a listing of tools

        '
    preconditions: 'A data connector implementation per the provided interfaces

        '
    postconditions: 'The data connector is able to provide a list of supported tools and interfaces

        '
    entry_point: test_tools_interface
    function_to_run: !python/function "# 1-test_tools_interface.py\n\n\nasync def test_tools_interface(zerg_state=None):\n\
        \    \"\"\"Test whether connector returns a valid list of tools\"\"\"\n    print(\"Testing connector tools interfaces\"\
        )\n\n    assert zerg_state, \"this test requires valid zerg_state\"\n\n    jira_url = zerg_state.get(\"jira_url\"\
        ).get(\"value\")\n    jira_api_token = zerg_state.get(\"jira_api_token\").get(\"value\")\n    jira_email = zerg_state.get(\"\
        jira_email\").get(\"value\")\n    confluence_url = zerg_state.get(\"confluence_url\").get(\"value\")\n    confluence_api_token\
        \ = zerg_state.get(\"confluence_api_token\").get(\"value\")\n    confluence_email = zerg_state.get(\"confluence_email\"\
        ).get(\"value\")\n    github_api_url = zerg_state.get(\"github_api_url\").get(\"value\")\n    github_access_token\
        \ = zerg_state.get(\"github_access_token\").get(\"value\")\n    sharepoint_url = zerg_state.get(\"sharepoint_url\"\
        ).get(\"value\")\n    sharepoint_client_id = zerg_state.get(\"sharepoint_client_id\").get(\"value\")\n    sharepoint_client_secret\
        \ = zerg_state.get(\"sharepoint_client_secret\").get(\"value\")\n    sharepoint_tenant_id = zerg_state.get(\"sharepoint_tenant_id\"\
        ).get(\"value\")\n    salesforce_username = zerg_state.get(\"salesforce_username\").get(\"value\")\n    salesforce_password\
        \ = zerg_state.get(\"salesforce_password\").get(\"value\")\n    salesforce_security_token = zerg_state.get(\"salesforce_security_token\"\
        ).get(\"value\")\n    salesforce_domain = zerg_state.get(\"salesforce_domain\").get(\"value\")\n    zendesk_subdomain\
        \ = zerg_state.get(\"zendesk_subdomain\").get(\"value\")\n    zendesk_email = zerg_state.get(\"zendesk_email\").get(\"\
        value\")\n    zendesk_api_token = zerg_state.get(\"zendesk_api_token\").get(\"value\")\n    asana_personal_access_token\
        \ = zerg_state.get(\"asana_personal_access_token\").get(\"value\")\n    sysaid_url = zerg_state.get(\"sysaid_url\"\
        ).get(\"value\")\n    sysaid_account_id = zerg_state.get(\"sysaid_account_id\").get(\"value\")\n    sysaid_username\
        \ = zerg_state.get(\"sysaid_username\").get(\"value\")\n    sysaid_password = zerg_state.get(\"sysaid_password\").get(\"\
        value\")\n    sysaid_api_key = zerg_state.get(\"sysaid_api_key\").get(\"value\")\n    trello_api_key = zerg_state.get(\"\
        trello_api_key\").get(\"value\")\n    trello_api_token = zerg_state.get(\"trello_api_token\").get(\"value\")\n   \
        \ trello_url = zerg_state.get(\"trello_url\").get(\"value\")\n\n    from connectors.trello.connector.config import\
        \ TrelloConnectorConfig\n    from connectors.trello.connector.connector import TrelloConnector, _get_secrets\n   \
        \ from connectors.trello.connector.target import TrelloTarget\n    from connectors.trello.connector.secrets import\
        \ TrelloSecrets\n    from common.models.secret import StorableSecret\n\n    from connectors.config import ConnectorConfig\n\
        \    from connectors.connector import Connector, ConnectorTargetInterface\n\n    # Note this is common code\n    from\
        \ common.models.tool import Tool\n    from pydantic import SecretStr\n\n    # Define an encryption key for testing\n\
        \    encryption_key = \"test_encryption_key_32_chars_long\"\n\n    # Initialize the connector config with StorableSecret\
        \ for jira_api_token\n    # The jira_api_token needs to be a StorableSecret which will encrypt the token\n    config\
        \ = TrelloConnectorConfig(\n        url=jira_url,\n        api_key=StorableSecret.model_validate(\n            {\"\
        secret\": jira_api_token}, \n            context={\"encryption_key\": encryption_key}\n        ),\n        email=jira_email,\n\
        \        url=confluence_url,\n        api_token=StorableSecret.model_validate(\n            {\"secret\": confluence_api_token},\
        \ \n            context={\"encryption_key\": encryption_key}\n        ),\n        email=confluence_email,\n      \
        \  url=github_api_url,\n        access_token=StorableSecret.model_validate(\n            {\"secret\": github_access_token},\
        \ \n            context={\"encryption_key\": encryption_key}\n        ),\n        url=sharepoint_url,\n        client_id=sharepoint_client_id,\n\
        \        client_secret=StorableSecret.model_validate(\n            {\"secret\": sharepoint_client_secret}, \n    \
        \        context={\"encryption_key\": encryption_key}\n        ),\n        tenant_id=sharepoint_tenant_id,\n     \
        \   username=salesforce_username,\n        password=StorableSecret.model_validate(\n            {\"secret\": salesforce_password},\
        \ \n            context={\"encryption_key\": encryption_key}\n        ),\n        security_token=StorableSecret.model_validate(\n\
        \            {\"secret\": salesforce_security_token}, \n            context={\"encryption_key\": encryption_key}\n\
        \        ),\n        domain=salesforce_domain,\n        subdomain=zendesk_subdomain,\n        email=zendesk_email,\n\
        \        api_token=StorableSecret.model_validate(\n            {\"secret\": zendesk_api_token}, \n            context={\"\
        encryption_key\": encryption_key}\n        ),\n        personal_access_token=StorableSecret.model_validate(\n    \
        \        {\"secret\": asana_personal_access_token}, \n            context={\"encryption_key\": encryption_key}\n \
        \       ),\n        url=sysaid_url,\n        account_id=sysaid_account_id,\n        username=sysaid_username,\n  \
        \      password=StorableSecret.model_validate(\n            {\"secret\": sysaid_password}, \n            context={\"\
        encryption_key\": encryption_key}\n        ),\n        api_key=StorableSecret.model_validate(\n            {\"secret\"\
        : sysaid_api_key}, \n            context={\"encryption_key\": encryption_key}\n        ),\n        api_key=StorableSecret.model_validate(\n\
        \            {\"secret\": trello_api_key}, \n            context={\"encryption_key\": encryption_key}\n        ),\n\
        \        api_token=StorableSecret.model_validate(\n            {\"secret\": trello_api_token}, \n            context={\"\
        encryption_key\": encryption_key}\n        ),\n        url=trello_url,\n    )\n    assert isinstance(config, ConnectorConfig),\
        \ \"TrelloConnectorConfig should be of type ConnectorConfig\"\n\n    # The connector is already instantiated as TrelloConnector,\
        \ not a class to instantiate\n    connector = TrelloConnector\n    \n    # TrelloConnector is an instance of Connector\n\
        \    assert isinstance(connector, Connector), \"TrelloConnector should be of type Connector\"\n\n    target = TrelloTarget()\n\
        \    assert isinstance(target, ConnectorTargetInterface), \"TrelloTarget should be of type ConnectorTargetInterface\"\
        \n\n    # Get secrets using the _get_secrets function directly\n    # This function is defined in connector.py and\
        \ passed to the Connector constructor\n    secrets = await _get_secrets(\n        config=config,\n        encryption_key=encryption_key,\n\
        \        user_token=None  # Not using user_token, using config.jira_api_token instead\n    )\n    assert secrets is\
        \ not None, \"Failed to get secrets\"\n    assert isinstance(secrets, TrelloSecrets), \"Secrets should be of type\
        \ TrelloSecrets\"\n    assert hasattr(secrets, 'api_key'), \"Secrets should have api_key attribute\"\n    assert isinstance(secrets.api_key,\
        \ SecretStr), \"api_key should be a SecretStr\"\n    assert hasattr(secrets, 'api_token'), \"Secrets should have api_token\
        \ attribute\"\n    assert isinstance(secrets.api_token, SecretStr), \"api_token should be a SecretStr\"\n    assert\
        \ hasattr(secrets, 'access_token'), \"Secrets should have access_token attribute\"\n    assert isinstance(secrets.access_token,\
        \ SecretStr), \"access_token should be a SecretStr\"\n    assert hasattr(secrets, 'client_secret'), \"Secrets should\
        \ have client_secret attribute\"\n    assert isinstance(secrets.client_secret, SecretStr), \"client_secret should\
        \ be a SecretStr\"\n    assert hasattr(secrets, 'password'), \"Secrets should have password attribute\"\n    assert\
        \ isinstance(secrets.password, SecretStr), \"password should be a SecretStr\"\n    assert hasattr(secrets, 'security_token'),\
        \ \"Secrets should have security_token attribute\"\n    assert isinstance(secrets.security_token, SecretStr), \"security_token\
        \ should be a SecretStr\"\n    assert hasattr(secrets, 'api_token'), \"Secrets should have api_token attribute\"\n\
        \    assert isinstance(secrets.api_token, SecretStr), \"api_token should be a SecretStr\"\n    assert hasattr(secrets,\
        \ 'personal_access_token'), \"Secrets should have personal_access_token attribute\"\n    assert isinstance(secrets.personal_access_token,\
        \ SecretStr), \"personal_access_token should be a SecretStr\"\n    assert hasattr(secrets, 'password'), \"Secrets\
        \ should have password attribute\"\n    assert isinstance(secrets.password, SecretStr), \"password should be a SecretStr\"\
        \n    assert hasattr(secrets, 'api_key'), \"Secrets should have api_key attribute\"\n    assert isinstance(secrets.api_key,\
        \ SecretStr), \"api_key should be a SecretStr\"\n    assert hasattr(secrets, 'api_key'), \"Secrets should have api_key\
        \ attribute\"\n    assert isinstance(secrets.api_key, SecretStr), \"api_key should be a SecretStr\"\n    assert hasattr(secrets,\
        \ 'api_token'), \"Secrets should have api_token attribute\"\n    assert isinstance(secrets.api_token, SecretStr),\
        \ \"api_token should be a SecretStr\"\n\n    # Get tools using the connector's get_tools function\n    # Note: get_tools\
        \ expects config, target, secrets, and cache\n    tools = connector.get_tools(\n        config=config,\n        target=target,\n\
        \        secrets=secrets,\n        cache=None  # Not using cache in this test\n    )\n    assert isinstance(tools,\
        \ list), \"Tools response is not a list\"\n    \n    for tool in tools:\n        assert isinstance(tool, Tool), f\"\
        Item {tool} is not an instance of Tool\"\n\n    # Verify expected tools are present\n    tool_names = [tool.name for\
        \ tool in tools]\n    assert \"get_trello_boards\" in tool_names, \"get_trello_boards tool not found\"\n    assert\
        \ \"get_trello_lists\" in tool_names, \"get_trello_lists tool not found\"\n    assert \"get_trello_cards\" in tool_names,\
        \ \"get_trello_cards tool not found\"\n\n    print(f\"Successfully retrieved {len(tools)} tools: {tool_names}\")\n\
        \n    return True"
-   description: 'This checks that the connector can successfully verify its connection

        '
    preconditions: |
        A connector implementation adhering to ConnectorInterface is available as 'connector'
    postconditions: |
        The check_connection method returns True if the connector is correctly configured
    entry_point: test_connector_check_connection
    function_to_run: !python/function "# -test_connector_check_connection.py\n\n\nasync def test_connector_check_connection(zerg_state=None):\n\
        \    \"\"\"Test whether connector can successfully verify its connection\"\"\"\n    print(\"Testing  connector connection\"\
        )\n\n    assert zerg_state, \"this test requires valid zerg_state\"\n\n    jira_url = zerg_state.get(\"jira_url\"\
        ).get(\"value\")\n    jira_api_token = zerg_state.get(\"jira_api_token\").get(\"value\")\n    jira_email = zerg_state.get(\"\
        jira_email\").get(\"value\")\n    confluence_url = zerg_state.get(\"confluence_url\").get(\"value\")\n    confluence_api_token\
        \ = zerg_state.get(\"confluence_api_token\").get(\"value\")\n    confluence_email = zerg_state.get(\"confluence_email\"\
        ).get(\"value\")\n    github_api_url = zerg_state.get(\"github_api_url\").get(\"value\")\n    github_access_token\
        \ = zerg_state.get(\"github_access_token\").get(\"value\")\n    sharepoint_url = zerg_state.get(\"sharepoint_url\"\
        ).get(\"value\")\n    sharepoint_client_id = zerg_state.get(\"sharepoint_client_id\").get(\"value\")\n    sharepoint_client_secret\
        \ = zerg_state.get(\"sharepoint_client_secret\").get(\"value\")\n    sharepoint_tenant_id = zerg_state.get(\"sharepoint_tenant_id\"\
        ).get(\"value\")\n    salesforce_username = zerg_state.get(\"salesforce_username\").get(\"value\")\n    salesforce_password\
        \ = zerg_state.get(\"salesforce_password\").get(\"value\")\n    salesforce_security_token = zerg_state.get(\"salesforce_security_token\"\
        ).get(\"value\")\n    salesforce_domain = zerg_state.get(\"salesforce_domain\").get(\"value\")\n    zendesk_subdomain\
        \ = zerg_state.get(\"zendesk_subdomain\").get(\"value\")\n    zendesk_email = zerg_state.get(\"zendesk_email\").get(\"\
        value\")\n    zendesk_api_token = zerg_state.get(\"zendesk_api_token\").get(\"value\")\n    asana_personal_access_token\
        \ = zerg_state.get(\"asana_personal_access_token\").get(\"value\")\n    sysaid_url = zerg_state.get(\"sysaid_url\"\
        ).get(\"value\")\n    sysaid_account_id = zerg_state.get(\"sysaid_account_id\").get(\"value\")\n    sysaid_username\
        \ = zerg_state.get(\"sysaid_username\").get(\"value\")\n    sysaid_password = zerg_state.get(\"sysaid_password\").get(\"\
        value\")\n    sysaid_api_key = zerg_state.get(\"sysaid_api_key\").get(\"value\")\n    trello_api_key = zerg_state.get(\"\
        trello_api_key\").get(\"value\")\n    trello_api_token = zerg_state.get(\"trello_api_token\").get(\"value\")\n   \
        \ trello_url = zerg_state.get(\"trello_url\").get(\"value\")\n\n    from connectors.trello.connector.config import\
        \ TrelloConnectorConfig\n    from connectors.trello.connector.connector import TrelloConnector, check_connection,\
        \ _get_secrets\n    from connectors.trello.connector.secrets import TrelloSecrets\n    from common.models.secret import\
        \ StorableSecret\n    \n    from connectors.config import ConnectorConfig\n    from connectors.connector import Connector\n\
        \    from pydantic import SecretStr\n\n    # Define an encryption key for testing\n    encryption_key = \"test_encryption_key_32_chars_long\"\
        \n\n    # Initialize the connector config with StorableSecret for jira_api_token\n    # The jira_api_token needs to\
        \ be a StorableSecret which will encrypt the token\n    config = TrelloConnectorConfig(\n        url=jira_url,\n \
        \       api_key=StorableSecret.model_validate(\n            {\"secret\": jira_api_token}, \n            context={\"\
        encryption_key\": encryption_key}\n        ),\n        email=jira_email,\n        url=confluence_url,\n        api_token=StorableSecret.model_validate(\n\
        \            {\"secret\": confluence_api_token}, \n            context={\"encryption_key\": encryption_key}\n    \
        \    ),\n        email=confluence_email,\n        url=github_api_url,\n        access_token=StorableSecret.model_validate(\n\
        \            {\"secret\": github_access_token}, \n            context={\"encryption_key\": encryption_key}\n     \
        \   ),\n        url=sharepoint_url,\n        client_id=sharepoint_client_id,\n        client_secret=StorableSecret.model_validate(\n\
        \            {\"secret\": sharepoint_client_secret}, \n            context={\"encryption_key\": encryption_key}\n\
        \        ),\n        tenant_id=sharepoint_tenant_id,\n        username=salesforce_username,\n        password=StorableSecret.model_validate(\n\
        \            {\"secret\": salesforce_password}, \n            context={\"encryption_key\": encryption_key}\n     \
        \   ),\n        security_token=StorableSecret.model_validate(\n            {\"secret\": salesforce_security_token},\
        \ \n            context={\"encryption_key\": encryption_key}\n        ),\n        domain=salesforce_domain,\n    \
        \    subdomain=zendesk_subdomain,\n        email=zendesk_email,\n        api_token=StorableSecret.model_validate(\n\
        \            {\"secret\": zendesk_api_token}, \n            context={\"encryption_key\": encryption_key}\n       \
        \ ),\n        personal_access_token=StorableSecret.model_validate(\n            {\"secret\": asana_personal_access_token},\
        \ \n            context={\"encryption_key\": encryption_key}\n        ),\n        url=sysaid_url,\n        account_id=sysaid_account_id,\n\
        \        username=sysaid_username,\n        password=StorableSecret.model_validate(\n            {\"secret\": sysaid_password},\
        \ \n            context={\"encryption_key\": encryption_key}\n        ),\n        api_key=StorableSecret.model_validate(\n\
        \            {\"secret\": sysaid_api_key}, \n            context={\"encryption_key\": encryption_key}\n        ),\n\
        \        api_key=StorableSecret.model_validate(\n            {\"secret\": trello_api_key}, \n            context={\"\
        encryption_key\": encryption_key}\n        ),\n        api_token=StorableSecret.model_validate(\n            {\"secret\"\
        : trello_api_token}, \n            context={\"encryption_key\": encryption_key}\n        ),\n        url=trello_url,\n\
        \    )\n    assert isinstance(config, ConnectorConfig), \"TrelloConnectorConfig should be of type ConnectorConfig\"\
        \n\n    # The connector is already instantiated as TrelloConnector\n    connector = TrelloConnector\n    assert isinstance(connector,\
        \ Connector), \"TrelloConnector should be of type Connector\"\n\n    # Get secrets for the connection check\n    secrets\
        \ = await _get_secrets(\n        config=config,\n        encryption_key=encryption_key,\n        user_token=None \
        \ # Not using user_token, using config. instead\n    )\n    assert secrets is not None, \"Failed to get secrets\"\n\
        \    assert isinstance(secrets, TrelloSecrets), \"Secrets should be of type TrelloSecrets\"\n\n    # Check connection\
        \ using the check_connection function directly\n    # Note: check_connection is a standalone function in connector.py\
        \ that takes config and secrets\n    connection_valid = await check_connection(\n        config=config,\n        secrets=secrets\n\
        \    )\n\n    if not isinstance(connection_valid, bool):\n        raise Exception(f\"check_connection did not return\
        \ a boolean, got {type(connection_valid)}\")\n    \n    if not connection_valid:\n        raise Exception(\"check_connection\
        \ returned False - connection failed\")\n\n    print(\"Connection check successful!\")\n\n    return True"
-   description: 'Query target options successfully enumerates available resources

        '
    preconditions: 'Valid API credentials configured for the connector

        '
    postconditions: |
        The get_query_target_options function retrieves a list of available resources;
        The returned options can be used to configure the connector's target selection;
        The connector config is properly subclassed from ConnectorConfig;
        The enumerated resources are real (not simulated) and match the expected API response format;
    entry_point: test_project_enumeration_options
    function_to_run: !python/function "# 3-test_query_target_options.py\n\n\nasync def test_project_enumeration_options(zerg_state=None):\n\
        \    \"\"\"Test Trello project enumeration by way of query target options\"\"\"\n    print(\"Attempting to authenticate\
        \ using Trello connector\")\n\n    assert zerg_state, \"this test requires valid zerg_state\"\n\n    jira_url = zerg_state.get(\"\
        jira_url\").get(\"value\")\n    jira_api_token = zerg_state.get(\"jira_api_token\").get(\"value\")\n    jira_email\
        \ = zerg_state.get(\"jira_email\").get(\"value\")\n    confluence_url = zerg_state.get(\"confluence_url\").get(\"\
        value\")\n    confluence_api_token = zerg_state.get(\"confluence_api_token\").get(\"value\")\n    confluence_email\
        \ = zerg_state.get(\"confluence_email\").get(\"value\")\n    github_api_url = zerg_state.get(\"github_api_url\").get(\"\
        value\")\n    github_access_token = zerg_state.get(\"github_access_token\").get(\"value\")\n    sharepoint_url = zerg_state.get(\"\
        sharepoint_url\").get(\"value\")\n    sharepoint_client_id = zerg_state.get(\"sharepoint_client_id\").get(\"value\"\
        )\n    sharepoint_client_secret = zerg_state.get(\"sharepoint_client_secret\").get(\"value\")\n    sharepoint_tenant_id\
        \ = zerg_state.get(\"sharepoint_tenant_id\").get(\"value\")\n    salesforce_username = zerg_state.get(\"salesforce_username\"\
        ).get(\"value\")\n    salesforce_password = zerg_state.get(\"salesforce_password\").get(\"value\")\n    salesforce_security_token\
        \ = zerg_state.get(\"salesforce_security_token\").get(\"value\")\n    salesforce_domain = zerg_state.get(\"salesforce_domain\"\
        ).get(\"value\")\n    zendesk_subdomain = zerg_state.get(\"zendesk_subdomain\").get(\"value\")\n    zendesk_email\
        \ = zerg_state.get(\"zendesk_email\").get(\"value\")\n    zendesk_api_token = zerg_state.get(\"zendesk_api_token\"\
        ).get(\"value\")\n    asana_personal_access_token = zerg_state.get(\"asana_personal_access_token\").get(\"value\"\
        )\n    sysaid_url = zerg_state.get(\"sysaid_url\").get(\"value\")\n    sysaid_account_id = zerg_state.get(\"sysaid_account_id\"\
        ).get(\"value\")\n    sysaid_username = zerg_state.get(\"sysaid_username\").get(\"value\")\n    sysaid_password =\
        \ zerg_state.get(\"sysaid_password\").get(\"value\")\n    sysaid_api_key = zerg_state.get(\"sysaid_api_key\").get(\"\
        value\")\n    trello_api_key = zerg_state.get(\"trello_api_key\").get(\"value\")\n    trello_api_token = zerg_state.get(\"\
        trello_api_token\").get(\"value\")\n    trello_url = zerg_state.get(\"trello_url\").get(\"value\")\n\n    from connectors.trello.connector.config\
        \ import TrelloConnectorConfig\n    from connectors.trello.connector.connector import TrelloConnector, get_query_target_options,\
        \ _get_secrets\n    from connectors.trello.connector.secrets import TrelloSecrets\n    from common.models.secret import\
        \ StorableSecret\n\n    from connectors.config import ConnectorConfig\n    from connectors.query_target_options import\
        \ ConnectorQueryTargetOptions\n    from connectors.connector import Connector\n    from pydantic import SecretStr\n\
        \n    # Define an encryption key for testing\n    encryption_key = \"test_encryption_key_32_chars_long\"\n\n    #\
        \ Initialize the connector config with StorableSecret for jira_api_token\n    # The jira_api_token needs to be a StorableSecret\
        \ which will encrypt the token\n    config = TrelloConnectorConfig(\n        url=jira_url,\n        api_key=StorableSecret.model_validate(\n\
        \            {\"secret\": jira_api_token}, \n            context={\"encryption_key\": encryption_key}\n        ),\n\
        \        email=jira_email,\n        url=confluence_url,\n        api_token=StorableSecret.model_validate(\n      \
        \      {\"secret\": confluence_api_token}, \n            context={\"encryption_key\": encryption_key}\n        ),\n\
        \        email=confluence_email,\n        url=github_api_url,\n        access_token=StorableSecret.model_validate(\n\
        \            {\"secret\": github_access_token}, \n            context={\"encryption_key\": encryption_key}\n     \
        \   ),\n        url=sharepoint_url,\n        client_id=sharepoint_client_id,\n        client_secret=StorableSecret.model_validate(\n\
        \            {\"secret\": sharepoint_client_secret}, \n            context={\"encryption_key\": encryption_key}\n\
        \        ),\n        tenant_id=sharepoint_tenant_id,\n        username=salesforce_username,\n        password=StorableSecret.model_validate(\n\
        \            {\"secret\": salesforce_password}, \n            context={\"encryption_key\": encryption_key}\n     \
        \   ),\n        security_token=StorableSecret.model_validate(\n            {\"secret\": salesforce_security_token},\
        \ \n            context={\"encryption_key\": encryption_key}\n        ),\n        domain=salesforce_domain,\n    \
        \    subdomain=zendesk_subdomain,\n        email=zendesk_email,\n        api_token=StorableSecret.model_validate(\n\
        \            {\"secret\": zendesk_api_token}, \n            context={\"encryption_key\": encryption_key}\n       \
        \ ),\n        personal_access_token=StorableSecret.model_validate(\n            {\"secret\": asana_personal_access_token},\
        \ \n            context={\"encryption_key\": encryption_key}\n        ),\n        url=sysaid_url,\n        account_id=sysaid_account_id,\n\
        \        username=sysaid_username,\n        password=StorableSecret.model_validate(\n            {\"secret\": sysaid_password},\
        \ \n            context={\"encryption_key\": encryption_key}\n        ),\n        api_key=StorableSecret.model_validate(\n\
        \            {\"secret\": sysaid_api_key}, \n            context={\"encryption_key\": encryption_key}\n        ),\n\
        \        api_key=StorableSecret.model_validate(\n            {\"secret\": trello_api_key}, \n            context={\"\
        encryption_key\": encryption_key}\n        ),\n        api_token=StorableSecret.model_validate(\n            {\"secret\"\
        : trello_api_token}, \n            context={\"encryption_key\": encryption_key}\n        ),\n        url=trello_url,\n\
        \    )\n    assert isinstance(config, ConnectorConfig), \"TrelloConnectorConfig should be of type ConnectorConfig\"\
        \n\n    # The connector is already instantiated as TrelloConnector\n    connector = TrelloConnector\n    assert isinstance(connector,\
        \ Connector), \"TrelloConnector should be of type Connector\"\n\n    # Get secrets for the query target options call\n\
        \    secrets = await _get_secrets(\n        config=config,\n        encryption_key=encryption_key,\n        user_token=None\
        \  # Not using user_token, using config.api_key instead\n    )\n    assert secrets is not None, \"Failed to get secrets\"\
        \n    assert isinstance(secrets, TrelloSecrets), \"Secrets should be of type TrelloSecrets\"\n\n    # Get query target\
        \ options using the standalone function\n    # Note: get_query_target_options is a function that takes config and\
        \ secrets\n    trello_query_target_options = await get_query_target_options(\n        config=config,\n        secrets=secrets\n\
        \    )\n    assert isinstance(trello_query_target_options, ConnectorQueryTargetOptions), \"query target options should\
        \ be of type ConnectorQueryTargetOptions\"\n\n    assert trello_query_target_options, \"Failed to retrieve query target\
        \ options\"\n\n    # Validate the structure of query target options\n    assert trello_query_target_options.definitions,\
        \ \"Query target options should have definitions\"\n    assert trello_query_target_options.selectors, \"Query target\
        \ options should have selectors\"\n    \n    # Check that we have the expected definition for project_keys\n    definition_names\
        \ = [d.name for d in trello_query_target_options.definitions]\n    # board_ids selector for target board\n    assert\
        \ \"board_ids\" in definition_names, \"board_ids should be in definitions\"\n\n    # Find the board_ids definition\
        \ and validate it\n    board_ids_def = next(d for d in trello_query_target_options.definitions if d.name == \"board_ids\"\
        )\n    assert board_ids_def.multiselect is True, \"board_ids should be multiselect\"\n    \n    # Check that we have\
        \ selectors with board values\n    assert len(trello_query_target_options.selectors) > 0, \"Should have at least one\
        \ selector\"\n    board_selector = next((s for s in trello_query_target_options.selectors if s.type == \"board_ids\"\
        ), None)\n    assert board_selector is not None, \"Should have a board_ids selector\"\n    assert len(board_selector.values)\
        \ > 0, \"Should have at least one board value\"\n    \n    # These should be real board_idss from Trello\n    print(f\"\
        Found {len(board_selector.values)} Trello boards: {board_selector.values}\")\n    \n    # Verify these are actual\
        \ board_ids\n    for board_key in board_selector.values:\n        assert isinstance(board_key, str), f\"board_ids\
        \ {board_key} should be a string\"\n        assert len(board_key) > 0, f\"board_ids should not be empty\"\n\n    print(f\"\
        trello query target option definitions: {trello_query_target_options.definitions}\")\n    print(f\"trello query target\
        \ option selectors: {trello_query_target_options.selectors}\")\n\n    return True"

specs:
-   description: Implementation does not simulate, fake, or use dummy implementations to cheat functionality
    preconditions: A valid implementation and configuration
    postconditions: "The implementation accomplishes the all specifications and unit tests and code \ndoes not simulate, cheat,\
        \ fake or use dummy implementations for any aspect of it's functionality;\nIt does not simulate API calls, data, or\
        \ anything else of this nature;"
-   description: "Connector Implementation handles API rate limiting and retries requests when needed per it's \nimplementation\
        \ in the code environment only"
    preconditions: A valid Connector implementation is provided
    postconditions: Connector gracefully handles rate-limiting responses;
-   description: "Evaluate that the Connector correctly inherits from ConnectorInterface as defined in \nconnector.py. The\
        \ spec will check that all required abstract methods are implemented \nand that the connector can successfully perform\
        \ a connection check using valid configuration."
    preconditions: Consider example connectors and connector interface as provided
    postconditions: "Connector inherits and defines all necessary requirements of ConnectorInterface per \nconnector.py per\
        \ the provided interface"
-   description: "This specification verifies that the Connector correctly implements tools functionality by \ninheriting\
        \ from ConnectorToolsInterface. It checks that all required abstract methods are \nimplemented and return appropriately\
        \ and that the interface methods are defined and callable, \nmatching the behavior of similar connectors provided\
        \ for comparison"
    preconditions: Consider example connectors and connector interface as provided
    postconditions: "Connector adheres to the ConnectorToolsInterface interface to define tools as defined in \ntools.py and\
        \ used in connector.py to define tools; consider the example connector's \ntools.py for examples and considerations"
-   description: "Connector implementation is entirely in the code environment, and does not require external \nresources\
        \ to be evaluated"
    preconditions: This spec has no strict preconditions
    postconditions: "Entirety of the connector implementation, per the provided interfaces, is entirely in the \ncode environment;"
-   description: "Ensure that tool methods associated with connector operations are implemented in the \ndedicated tool class\
        \ rather than within the main connector class, this holds for other classes\nas well"
    preconditions: "A connector exists which implements a main ConnectorInterface along with a separate \nConnectorToolsInterface;\
        \ tool methods should be clearly defined in the tool class"
    postconditions: "The specification must confirm that all methods used to interact with external APIs \n(e.g., get_asset_info,\
        \ get_vulnerabilities, etc.) are part of the tool class \nimplementation (i.e., subclass of ConnectorToolsInterface)\
        \ and not mixed into the main \nconnector class - this should intently hold for other classes in the architecture"
-   description: "Specification to ensure that the Connector delegates core functionality to its dedicated \ntool class rather\
        \ than having duplicate or recursive logic within the connector. \nThis spec checks that tools contain the implementation\
        \ logic for interacting with the connector data\nsource, and that the connector only serves as a configuration holder\
        \ and dispatch mechanism"
    preconditions: "Connector must be instantiated with a valid configuration; Connector.get_tools() should \nreturn a non-empty\
        \ list of Tool objects where each tool has an execute_fn defined; \nthe environment simulates API calls"
    postconditions: "For each core functionality tool provided by Connector the specification must verify \nthat the implementation\
        \ logic resides in the tool class and not as \nredundant direct calls in the Connector. The spec should fail if the\
        \ tool’s execute_fn \nsimply wraps a call back to the connector's methods or if there is any sign of duplicate \n\
        business logic in both the connector and tool layers"
-   description: "Specification to ensure that the Connector code maintains high stylistic quality and does not contain dead,\
        \ \nduplicate, or unnecessary code. This spec checks that the implementation follows consistent coding \npatterns,\
        \ is well-organized, and only includes code that serves a functional purpose."
    preconditions: "Connector implementation is complete and functional; all classes and methods are defined \nand accessible;\
        \ the code compiles without errors"
    postconditions: "The specification must verify that: (1) No unreachable or \"dead\" code exists in the implementation;\
        \ \n(2) No duplicate functionality is implemented in multiple places; (3) All imports are actually used; \n(4) The\
        \ code follows a consistent style with proper naming conventions, indentation, and organization; \n(5) There are no\
        \ commented-out code blocks or TODOs that should have been resolved; \n(6) No unnecessary abstractions or overly complex\
        \ structures exist where simpler solutions would suffice; \n(7) All \"placeholder\" or \"stub\" code has been replaced\
        \ with actual implementations"
-   description: "Specification to ensure that the Connector implementation does not contain any monkey-patches \nor runtime\
        \ modifications to existing classes, methods, or modules. This ensures code maintainability, \npredictability, and\
        \ compatibility with the framework."
    preconditions: "Connector implementation is complete and functional; all modules and classes are imported \nand initialized;\
        \ the code compiles without errors"
    postconditions: "The specification must verify that: (1) No monkey-patching of framework classes or methods exists \n\
        in the implementation; (2) No runtime modifications to class attributes or methods occur; \n(3) No dynamic attribute\
        \ assignment to external modules or classes is present; (4) No use of \nsetattr() or similar techniques to modify\
        \ behavior of imported modules; (5) All functionality \nis implemented through proper inheritance, composition, or\
        \ standard method overriding; \n(6) The code does not modify __dict__, __class__, or other special attributes of external\
        \ objects; \n(7) No patching of built-in functions or standard library modules occurs"
-   description: "Specification to ensure that every tool, method, and input model in the implementation \nincludes sufficiently\
        \ descriptive docstrings."
    preconditions: "Connector implementation is complete and contains all required tools, models, and methods; \nthe code\
        \ compiles without errors"
    postconditions: "The specification must verify that: (1) Every public class, method, and function has a docstring that\
        \ \nclearly explains its purpose and usage; Most critically, the docstring MUST include how the \nfunction should\
        \ be used in terms of parameters and return values - this is especially critical \nfor connector tools"

references:
-   file_path: andesite/connectors_code/connectors/tenable/connector/connector.py
    workspace_path: workspace/tenable_connector_example/connector.py
    description: example connector.py of a tenable connector for purpose of comparison
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/tenable/connector/config.py
    workspace_path: workspace/tenable_connector_example/config.py
    description: example config.py of a tenable connector for purpose of comparison
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/tenable/connector/target.py
    workspace_path: workspace/tenable_connector_example/target.py
    description: example target.py of a tenable connector for purpose of comparison
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/tenable/connector/tools.py
    workspace_path: workspace/tenable_connector_example/tools.py
    description: example tools.py of a tenable connector for purpose of comparison
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/splunk/connector/connector.py
    workspace_path: workspace/splunk_connector_example/connector.py
    description: example connector.py of a splunk connector for purpose of comparison
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/splunk/connector/alerts.py
    workspace_path: workspace/splunk_connector_example/alerts.py
    description: example alerts.py of a splunk connector for purpose of comparison
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/splunk/connector/config.py
    workspace_path: workspace/splunk_connector_example/config.py
    description: example config.py of a splunk connector for purpose of comparison
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/splunk/connector/target.py
    workspace_path: workspace/splunk_connector_example/target.py
    description: example target.py of a splunk connector for purpose of comparison
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/splunk/connector/tools.py
    workspace_path: workspace/splunk_connector_example/tools.py
    description: example tools.py of a splunk connector for purpose of comparison
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/cache.py
    environment_path: connectors/cache.py
    description: cache.py
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/config.py
    environment_path: connectors/config.py
    description: config.py defines the connector config interfaces that the connector must use
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/connector.py
    environment_path: connectors/connector.py
    description: connector.py defines the connector interface that the connector must adhere to and inherit
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/initialize_connector_scopes.py
    environment_path: connectors/initialize_connector_scopes.py
    description: initialize_connector_scopes.py defines connector scope initialization
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/main.py
    environment_path: connectors/main.py
    description: main.py
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/metrics.py
    environment_path: connectors/metrics.py
    description: metrics.py defines the connector metrics interfaces that the connector must use
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/parse_alert_configs.py
    environment_path: connectors/parse_alert_configs.py
    description: parse_alert_configs.py defines parsing functions that the connector may use
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/query_instance.py
    environment_path: connectors/query_instance.py
    description: 'query_instance.py defines the query instance that the connector needs to use '
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/query_target_options.py
    environment_path: connectors/query_target_options.py
    description: query_target_options.py defines the connector query_target_options interfaces that the connector must use
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/registry.py
    environment_path: connectors/registry.py
    description: registry.py defines the connector registry and respective interfaces that the connector must adhere to
    format: python
    required: true
    read_only: true
-   file_path: andesite/connectors_code/connectors/tools.py
    environment_path: connectors/tools.py
    description: tools.py defines the interface of the tools the connector must implement and define
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/base/collection_manager.py
    environment_path: common/base/collection_manager.py
    description: collection_manager.py provides an abstract base class for MongoDB collection management with singleton pattern
        implementation and asynchronous initialization interface
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/clients/mongodb_client.py
    environment_path: common/clients/mongodb_client.py
    description: common/clients/mongodb_client.py
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/jsonlogging/jsonlogger.py
    environment_path: common/jsonlogging/jsonlogger.py
    description: jsonlogger.py provides structured JSON logging functionality with context tracking and formatting for API
        requests
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/managers/dataset_descriptions/dataset_description_manager.py
    environment_path: common/managers/dataset_descriptions/dataset_description_manager.py
    description: dataset_description_manager.py implements MongoDB-based storage and retrieval of dataset metadata with async
        support and telemetry
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/managers/dataset_descriptions/dataset_description_model.py
    environment_path: common/managers/dataset_descriptions/dataset_description_model.py
    description: dataset_description_model.py defines the Pydantic data model for dataset metadata with MongoDB serialization
        support
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/managers/dataset_structures/dataset_structure_model.py
    environment_path: common/managers/dataset_structures/dataset_structure_model.py
    description: dataset_structure_model.py defines the Pydantic data model for dataset schemas with flexible attribute storage
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/managers/enterprise_technique/enterprise_technique_manager.py
    environment_path: common/managers/enterprise_technique/enterprise_technique_manager.py
    description: enterprise_technique_manager.py implements MongoDB storage and retrieval for MITRE ATT&CK Enterprise techniques
        with prioritization support
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/managers/prioritization_rules/prioritization_rules_manager.py
    environment_path: common/managers/prioritization_rules/prioritization_rules_manager.py
    description: prioritization_rules_manager.py implements MongoDB persistence for analysis prioritization rules with async
        operations and telemetry tracing
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/managers/prioritization_rules/prioritization_rules_model.py
    environment_path: common/managers/prioritization_rules/prioritization_rules_model.py
    description: prioritization_rules_model.py defines the Pydantic data model for regex-based analysis prioritization with
        data validation
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/managers/user/user_model.py
    environment_path: common/managers/user/user_model.py
    description: user_model.py defines the Pydantic model for user data with secure token encryption/decryption capabilities
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/managers/user/user_manager.py
    environment_path: common/managers/user/user_manager.py
    description: common/managers/user/user_manager.py
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/models/alerts.py
    environment_path: common/models/alerts.py
    description: common/models/alerts.py
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/models/connector_id_enum.py
    environment_path: common/models/connector_id_enum.py
    description: common/models/connector_id_enum.py
    format: python
    required: true
    read_only: false
-   file_path: andesite/common_code/common/models/cron_config.py
    environment_path: common/models/cron_config.py
    description: cron_config.py defines a Pydantic model for cron expressions with validation and field parsing
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/models/secret.py
    environment_path: common/models/secret.py
    description: secret.py
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/models/tool.py
    environment_path: common/models/tool.py
    description: tool.py implements a framework for executable tools with input validation, telemetry and standardized result
        formatting
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/models/metadata.py
    environment_path: common/models/metadata.py
    description: metadata.py used by tool.py
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/models/mitre.py
    environment_path: common/models/mitre.py
    description: mitre.py
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/opentelemetry/context.py
    environment_path: common/opentelemetry/context.py
    description: common/opentelemetry/context.py
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/utils/fallback_none.py
    environment_path: common/utils/fallback_none.py
    description: fallback_none.py provides a utility function for graceful Pydantic model validation with None fallback
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/utils/flatten_dict.py
    environment_path: common/utils/flatten_dict.py
    description: flatten_dict.py
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/utils/context.py
    environment_path: common/utils/context.py
    description: context.py
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/utils/pydantic_helper.py
    environment_path: common/utils/pydantic_helper.py
    description: pydantic_helper.py
    format: python
    required: true
    read_only: true
-   file_path: andesite/common_code/common/utils/timer.py
    environment_path: common/utils/timer.py
    description: timer.py
    format: python
    required: true
    read_only: true

configs:
-   name: considerations
    value:
    - you are a top-tier data connector engineer, with an eye for detail and architecture - plus you're nice and easy to work
        with
    - ensure that you adhere to the connector architecture as defined in the connectors interface and provided connector examples
    - do not fake functionality, do not pass back simulated values - all functionality must work in the context of the connector
        specs, specifications and requirements
    - note that connectors may call to common code, this is not available - when this is the case, simply stub this out as
        needed
    - if an import failes, consider whether it's common code or a missing package - if missing package, install the package
        do not shim what are obvious dependencies
    - note that code in the connectors framework, with the exception of the enums, is read only and cannot be edited, modified
        or otherwise and must be used as is
    - if you find yourself hitting the same error, or issue, please consider 2-3 alternative approaches and choose one of
        them to try next
    - __init__.py files should not contain code, but they should be created as empty files as needed
    description: "Various considerations for the generation of connectors with regards to the connector framework \nas provided\
        \ - please keep these strongly in mind\n"
