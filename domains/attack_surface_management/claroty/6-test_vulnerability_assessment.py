# 6-test_vulnerability_assessment.py

async def test_vulnerability_assessment(zerg_state=None):
    """Test Claroty vulnerability assessment and risk analysis retrieval by way of connector tools"""
    print("Attempting to authenticate using Claroty connector")

    assert zerg_state, "this test requires valid zerg_state"

    claroty_server_url = zerg_state.get("claroty_server_url").get("value")
    claroty_api_token = zerg_state.get("claroty_api_token").get("value")
    claroty_username = zerg_state.get("claroty_username").get("value")
    claroty_password = zerg_state.get("claroty_password").get("value")
    claroty_api_version = zerg_state.get("claroty_api_version").get("value")

    from connectors.claroty.config import ClarotyConnectorConfig
    from connectors.claroty.connector import ClarotyConnector
    from connectors.claroty.tools import ClarotyConnectorTools, GetVulnerabilityAssessmentInput
    from connectors.claroty.target import ClarotyTarget

    from connectors.config import ConnectorConfig
    from connectors.connector import Connector, ConnectorTargetInterface
    from connectors.query_target_options import ConnectorQueryTargetOptions

    # set up the config
    config = ClarotyConnectorConfig(
        server_url=claroty_server_url,
        api_token=claroty_api_token,
        username=claroty_username,
        password=claroty_password,
        api_version=claroty_api_version
    )
    assert isinstance(config, ConnectorConfig), "ClarotyConnectorConfig should be of type ConnectorConfig"

    # set up the connector
    connector = ClarotyConnector
    await connector.initialize(
        config=config,
        user_id="test_user_id",
        encryption_key="test_enc_key"
    )
    assert isinstance(connector, Connector), "ClarotyConnector should be of type Connector"

    # get query target options
    claroty_query_target_options = await connector.get_query_target_options()
    assert isinstance(claroty_query_target_options, ConnectorQueryTargetOptions), "query target options should be of type ConnectorQueryTargetOptions"

    # select asset types to target
    asset_type_selector = None
    for selector in claroty_query_target_options.selectors:
        if selector.type == 'asset_types':  
            asset_type_selector = selector
            break

    assert asset_type_selector, "failed to retrieve asset type selector from query target options"

    assert isinstance(asset_type_selector.values, list), "asset_type_selector values must be a list"
    asset_type = asset_type_selector.values[0] if asset_type_selector.values else None
    print(f"Selecting asset type: {asset_type}")

    assert asset_type, f"failed to retrieve asset type from asset type selector"

    # select security zones to target (optional)
    zone_selector = None
    for selector in claroty_query_target_options.selectors:
        if selector.type == 'security_zones':  
            zone_selector = selector
            break

    security_zone = None
    if zone_selector and isinstance(zone_selector.values, list) and zone_selector.values:
        security_zone = zone_selector.values[0]
        print(f"Selecting security zone: {security_zone}")

    # set up the target with asset types and security zones
    target = ClarotyTarget(asset_types=[asset_type], security_zones=[security_zone] if security_zone else None)
    assert isinstance(target, ConnectorTargetInterface), "ClarotyTarget should be of type ConnectorTargetInterface"

    # get tools
    tools = await connector.get_tools(
        target=target
    )
    assert isinstance(tools, list), "Tools response is not a list"

    # grab the get_claroty_vulnerability_assessment tool and execute it with risk filter
    get_vulnerability_assessment_tool = next(tool for tool in tools if tool.name == "get_claroty_vulnerability_assessment")
    
    # Filter for High and Critical risk vulnerabilities
    vulnerability_result = await get_vulnerability_assessment_tool.execute(risk_level="High", include_cve_details=True, limit=50)
    claroty_vulnerabilities = vulnerability_result.result

    print("Type of returned claroty_vulnerabilities:", type(claroty_vulnerabilities))
    print(f"len vulnerabilities: {len(claroty_vulnerabilities)} vulnerabilities: {str(claroty_vulnerabilities)[:200]}")

    # Verify that claroty_vulnerabilities is a list
    assert isinstance(claroty_vulnerabilities, list), "claroty_vulnerabilities should be a list"
    assert len(claroty_vulnerabilities) > 0, "claroty_vulnerabilities should not be empty"
    
    # Limit the number of vulnerabilities to check if there are many
    vulnerabilities_to_check = claroty_vulnerabilities[:5] if len(claroty_vulnerabilities) > 5 else claroty_vulnerabilities
    
    # Verify structure of each vulnerability object
    for vulnerability in vulnerabilities_to_check:
        # Verify essential Claroty vulnerability fields
        assert "id" in vulnerability, "Each vulnerability should have an 'id' field"
        assert "cve_id" in vulnerability, "Each vulnerability should have a 'cve_id' field"
        assert "risk_score" in vulnerability, "Each vulnerability should have a 'risk_score' field"
        
        # Verify CVE ID format (basic validation)
        cve_id = vulnerability["cve_id"]
        if cve_id and cve_id != "N/A":
            assert isinstance(cve_id, str), "CVE ID should be a string"
            assert cve_id.startswith("CVE-"), f"CVE ID should start with 'CVE-', got: {cve_id}"
        
        # Verify risk score is numeric
        risk_score = vulnerability["risk_score"]
        assert isinstance(risk_score, (int, float)), f"Risk score should be numeric, got: {type(risk_score)}"
        assert 0 <= risk_score <= 10, f"Risk score should be between 0-10, got: {risk_score}"
        
        # Check for essential vulnerability assessment fields
        essential_fields = ["title", "description", "severity", "discovery_date"]
        for field in essential_fields:
            assert field in vulnerability, f"Vulnerability should contain '{field}' field"
        
        # Verify severity is one of the expected values
        valid_severities = ["Low", "Medium", "High", "Critical"]
        assert vulnerability["severity"] in valid_severities, f"Vulnerability severity {vulnerability['severity']} should be one of {valid_severities}"
        
        # Check for affected assets information
        assert "affected_assets" in vulnerability, "Each vulnerability should have an 'affected_assets' field"
        affected_assets = vulnerability["affected_assets"]
        assert isinstance(affected_assets, list), "Affected assets should be a list"
        
        if len(affected_assets) > 0:
            asset = affected_assets[0]  # Check first affected asset
            asset_fields = ["asset_id", "asset_name", "ip_address", "asset_type", "firmware_version"]
            present_asset_fields = [field for field in asset_fields if field in asset]
            print(f"Affected asset contains: {', '.join(present_asset_fields)}")
            
            # Verify asset type matches target if specified
            if "asset_type" in asset:
                assert asset["asset_type"] == asset_type, f"Asset type {asset['asset_type']} should match target {asset_type}"
        
        # Check for CVE and vulnerability intelligence details
        cve_fields = ["cvss_score", "cvss_vector", "cwe_id", "exploit_available", "patch_available"]
        present_cve = [field for field in cve_fields if field in vulnerability]
        print(f"Vulnerability {vulnerability['id']} contains these CVE fields: {', '.join(present_cve)}")
        
        # Validate CVSS score if present
        if "cvss_score" in vulnerability and vulnerability["cvss_score"]:
            cvss_score = vulnerability["cvss_score"]
            assert isinstance(cvss_score, (int, float)), "CVSS score should be numeric"
            assert 0 <= cvss_score <= 10, f"CVSS score should be between 0-10, got: {cvss_score}"
        
        # Check for exploit and threat intelligence
        threat_fields = ["exploit_maturity", "threat_actors", "attack_vectors", "exploitability_score"]
        present_threat = [field for field in threat_fields if field in vulnerability]
        print(f"Vulnerability {vulnerability['id']} contains these threat fields: {', '.join(present_threat)}")
        
        # Check for remediation and mitigation information
        remediation_fields = ["remediation_steps", "mitigation_options", "patch_information", "workarounds"]
        present_remediation = [field for field in remediation_fields if field in vulnerability]
        print(f"Vulnerability {vulnerability['id']} contains these remediation fields: {', '.join(present_remediation)}")
        
        # Check for business and operational impact
        impact_fields = ["business_impact", "operational_impact", "safety_impact", "availability_impact"]
        present_impact = [field for field in impact_fields if field in vulnerability]
        print(f"Vulnerability {vulnerability['id']} contains these impact fields: {', '.join(present_impact)}")
        
        # Check for compliance and regulatory context
        compliance_fields = ["regulatory_requirements", "compliance_frameworks", "industry_standards"]
        present_compliance = [field for field in compliance_fields if field in vulnerability]
        if present_compliance:
            print(f"Vulnerability {vulnerability['id']} contains these compliance fields: {', '.join(present_compliance)}")
        
        # Verify security zone context if zones were selected
        if security_zone:
            zone_fields = ["security_zone", "zone_id", "network_segment"]
            present_zone = [field for field in zone_fields if field in vulnerability]
            if present_zone:
                print(f"Vulnerability {vulnerability['id']} contains these zone fields: {', '.join(present_zone)}")
        
        # Check for timeline and tracking information
        timeline_fields = ["first_detected", "last_updated", "remediation_deadline", "status"]
        present_timeline = [field for field in timeline_fields if field in vulnerability]
        print(f"Vulnerability {vulnerability['id']} contains these timeline fields: {', '.join(present_timeline)}")
        
        # Log the structure of the first vulnerability for debugging
        if vulnerability == vulnerabilities_to_check[0]:
            print(f"Example vulnerability structure: {vulnerability}")

    print(f"Successfully retrieved and validated {len(claroty_vulnerabilities)} Claroty vulnerability assessments")

    return True