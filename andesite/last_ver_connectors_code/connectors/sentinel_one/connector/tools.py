import json
from enum import Enum
from typing import Any, Literal, Optional

import httpx
from common.jsonlogging.jsonlogger import Logging
from common.models.metadata import QueryResultMetadata
from common.models.tool import Tool, ToolResult
from connectors.sentinel_one.connector.target import SentinelOneTarget
from opentelemetry import trace
from pydantic import BaseModel, Field, model_validator

from connectors.connector_id_enum import ConnectorIdEnum
from connectors.sentinel_one.connector.config import SentinelOneConnectorConfig
from connectors.tools import ConnectorToolsInterface

tracer = trace.get_tracer(__name__)
logger = Logging.get_logger(__name__)


class SentinelOneResource(Enum):
    ENDPOINT = "/web/api/v2.1/xdr/assets/surface/endpoint"
    THREAT = "/web/api/v2.1/threats"
    ALERTS = "/web/api/v2.1/cloud-detection/alerts"

    def __init__(self, api_path: str):
        self.api_path = api_path


class SentinelOneConnectorException(Exception):
    pass


class SentinelOneConnectorTools(ConnectorToolsInterface):
    QUERY_RESULT_METADATA_FORMAT = "SentinelOne API"

    def __init__(self, display_name: str, config: SentinelOneConnectorConfig):
        super().__init__(connector=ConnectorIdEnum.SENTINEL_ONE, target=SentinelOneTarget(), connector_display_name=display_name)
        self.api_endpoint = config.api_endpoint
        if config.token:
            self.headers = {"Authorization": f"ApiToken {config.token.get_secret_value()}"}
        else:
            logger().error("SentinelOne token is not set")
            self.headers = {}

    class GetResourceInput(BaseModel):
        cursor: Optional[str] = Field(
            default=None,
            description="To retrieve the next page of results, you can provide a cursor. "
            + "The cursor is stored in the 'nextCursor' field in the 'pagination' object in the response. "
            + "If 'nextCursor' is not null, that means there are more results.",
        )
        limit: Optional[int] = Field(
            default=None,
            ge=1,
            le=100,
            description="By default the API returns up to 50 items. You can modify this by passing a limit value up to 100. "
            + "Unless the user explicitly requests a limit, you should should not provide this value.",
        )
        skip: Optional[int] = Field(
            default=None,
            ge=1,
            le=1000,
            description="If you want to only see items after a certain number of results, you can provide a value here. "
            + "You can skip up to the first 1000 items. Unless the user explicitly requests to skip results, you should should not provide this value.",
        )
        sort_by: Optional[str] = Field(
            default=None,
            serialization_alias="sortBy",
            description="This parameter allows you sort by a certain field in the response. Not all fields can be sorted on. It is optional.",
        )
        sort_order: Optional[Literal["asc", "desc"]] = Field(
            default=None,
            serialization_alias="sortOrder",
            description="If sort_by is provided, you can sort the results in ascending order with the parameter value 'asc'. For descending order, provide the value 'desc'.",
        )

        @model_validator(mode="after")
        def check_sort_by_is_provided(self):
            if self.sort_order is not None and self.sort_by is None:
                raise ValueError("sortBy is required when sortOrder is set")
            return self

    class GetEndpointsInput(GetResourceInput):
        """
        Endpoints are assets monitored by SentinelOne. They are generally personal laptops or servers.
        The endpoints API returns information about endpoints currently managed and metadata about agents installed on them.
        """

        pass

    class GetThreatsInput(GetResourceInput):
        """
        Threats are generated by SentinelOne when:
            - The SentinelOne Agent engines detect suspicious or malicious activity.
            - A user marks events as suspicious or malicious in the API, SentinelCTL, or in Deep Visibility™ or Singularity™ Data Lake.
        SentinelOne maintains a list of specific threats to monitor. Threats are also generated based on the policy set for the organization.
        To understand what caused a threat, look at the "indicators" field in the response.
        """

        pass

    class GetAlertsInput(GetResourceInput):
        """
        Alerts are generated by SentinelOne based on custom rules the user has configured.
        The "rule_info" field will denote which rule triggered the alert.
        """

        pass

    def get_tools(self) -> list[Tool]:
        return [
            Tool(connector=self._connector_display_name, name="get_endpoints", execute_fn=self.get_endpoints_async),
            Tool(connector=self._connector_display_name, name="get_threats", execute_fn=self.get_threats_async),
            Tool(connector=self._connector_display_name, name="get_alerts", execute_fn=self.get_alerts_async),
        ]

    async def get_endpoints_async(self, input: GetEndpointsInput) -> ToolResult:
        response_json = await self._get_s1_resource_async(SentinelOneResource.ENDPOINT, input)
        return self.convert_to_tool_response(SentinelOneResource.ENDPOINT, response_json)

    async def get_threats_async(self, input: GetThreatsInput) -> ToolResult:
        response_json = await self._get_s1_resource_async(SentinelOneResource.THREAT, input)
        return self.convert_to_tool_response(SentinelOneResource.THREAT, response_json)

    async def get_alerts_async(self, input: GetAlertsInput) -> ToolResult:
        response_json = await self._get_s1_resource_async(SentinelOneResource.ALERTS, input)
        return self.convert_to_tool_response(SentinelOneResource.ALERTS, response_json)

    @tracer.start_as_current_span("get_s1_resource_async")
    async def _get_s1_resource_async(
        self, resource: SentinelOneResource, input: GetResourceInput
    ) -> Any:
        api_request: dict[str, Any] = self.generate_params_from_input(input)
        async with httpx.AsyncClient() as client:
            try:
                response = await client.get(
                    f"{self.api_endpoint}{resource.api_path}", headers=self.headers, **api_request
                )
                response.raise_for_status()
                return response.json()
            except httpx.RequestError:
                logger().exception(f"An error occurred while requesting {resource.name}.")
                raise SentinelOneConnectorException("Unable to connect to SentinelOne")  # noqa: B904
            except httpx.HTTPStatusError as e:
                logger().exception(f"Error response {e.response.status_code} while requesting {resource.name}.")
                if e.response.status_code == 401:
                    raise SentinelOneConnectorException("SentinelOne API token is not set or unauthorized")  # noqa: B904
                raise SentinelOneConnectorException(f"SentinelOne returned an HTTP error {e.response.status_code}, {e.response.text}")  # noqa: B904
            except Exception:
                logger().exception("Unknown error from S1")
                raise SentinelOneConnectorException("Unknown error from SentinelOne")  # noqa: B904

    def generate_params_from_input(self, input: GetResourceInput) -> dict[str, Any]:
        params = input.model_dump(exclude_unset=True, by_alias=True, exclude_defaults=True)
        if len(params) > 0:
            api_request: dict[str, Any] = {"params": {}}
            api_request["params"].update(params)
            return api_request
        return {}

    def convert_to_tool_response(
        self, resource: SentinelOneResource, json_response: Any
    ) -> ToolResult:
        response = json.dumps(json_response)
        qrm = QueryResultMetadata(
            query=resource.api_path,
            column_headers=None,
            query_format=self.QUERY_RESULT_METADATA_FORMAT,
            results=[[response]],
        )
        return ToolResult(result=response, additional_context=None)
